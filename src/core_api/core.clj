(ns core-api.core
  (:gen-class))

(require '[core-api.context :as context])
(require '[core-api.api     :as api])
(require '[core-api.place   :as place])

;; Test programs

;; Test 1 - write hello when the user enters anything
(defn write-hello [_]
  {context/stdout "hola!"})

;; Test 2 - echo what the user input when they enter something
(defn write-input [place-map]
  {context/stdout (:stdin place-map)})

;; Test 3 - increment an atomic counter by 1 everytime the user inputs something
(defn write-inc-place [place-map]
  {context/custom-out (inc (:custom-in place-map))
   context/stdout     (:custom-in place-map)})

;; Test 4 - echo user input until they type "quit", thereupon the program exits
(defn write-input-until-quit [place-map]
  (let [user-input (:stdin place-map)]
    (if (= user-input "quit")
      {context/exit 0}
      {context/stdout user-input})))

;; Test 5 - write to both stdout and an atomic string;
;;          all user input is saved in the atomic string, so everytime the user 
;;          inputs a string, that string will be appended to the saved one
(def example-spread-place 
  ;; this a call to "spread"; the notion being that all data sent to this place
  ;; will actually be sent to multiple other places by a function
  (place/spread
    (fn [val]
      {context/stdout val
       context/custom-out2 val})))

(defn write-spread [place-map]
  ;; this is the event handler that "sends" data to the spread place generated above
  {example-spread-place (str (:custom-in2 place-map) (:stdin place-map))})

;; Test 6 - read from two places at once;
;;          prints the number of times a user has input something,
;;          along with their input
(def example-connect-place
  ;; this is a call to "connect"; the notion being that data that comes from
  ;; the place generated by this call is actually from multiple other places
  (place/connect
    :example-connect-place              ;; the "name" of the new place
    [context/stdin context/custom-in]   ;; the other places it gets its data from
    (fn [place-map]                     ;; a function that creates the value
                                        ;;  that the "reader" of the place sees
      (str (:custom-in place-map) ". " (:stdin place-map)))))

(defn read-connect [place-map]
  ;; this is the event handler that "reads" from the connected place generated above
  {context/stdout (:example-connect-place place-map)
   context/custom-out (inc (:custom-in place-map))})

;; Test 7 - writes hello to stdout immediately when the program begins
(defn write-hello-and-quit [_]
  {context/stdout "Hello!"
   context/exit 0})

;; Test 8 - calls the "write-hello-and-quit" event-handler 5 seconds after start
(defn start-timeout [_]
  {context/stdout "Starting..."
   context/timeout 5000})

;; Apply context to the "on-event" function from the core-api
(def on-event (api/add-context context/context))

;; run tests, comment out other tests
(defn -main [& args]
  (do
    ;; (on-event :read-line-event [] write-hello)                                           ;; Test 1
    ;; (on-event :read-line-event [context/stdin] write-input)                              ;; Test 2
    ;; (on-event :read-line-event [context/custom-in] write-inc-place)                      ;; Test 3
    ;; (on-event :read-line-event [context/stdin] write-input-until-quit)                   ;; Test 4
    ;; (on-event :read-line-event [context/stdin context/custom-in2] write-spread)          ;; Test 5
    ;; (on-event :read-line-event [example-connect-place context/custom-in] read-connect)   ;; Test 6
    ;; (on-event :start [] write-hello-and-quit)                                            ;; Test 7
    (on-event :start [] start-timeout)                                                   ;; Test 8
    (on-event :timeout-event [] write-hello-and-quit)                                    ;; Test 8, also
    ;; wait until the program has been manually terminated
    (api/endless!)))


